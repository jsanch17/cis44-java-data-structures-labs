
package exam3.lru.cache;

import java.util.HashMap;
import java.util.Map;

/**
 * LRU Cache implemented with HashMap + DoublyLinkedList.
 *
 * Core Algorithms (O(1) average time):
 *  - get(key): lookup; if hit, move node to MRU; return value; else return -1
 *  - put(key, value): insert or update; if full, evict LRU (tail) then insert at MRU
 */
public class LRUCache {
    private final int capacity;
    private final Map<Integer, Node> map = new HashMap<>();
    private final DoublyLinkedList list = new DoublyLinkedList();

    public LRUCache(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be > 0");
        }
        this.capacity = capacity;
    }

    /**
     * Lookup:
     * - If present: move to MRU and return value
     * - If absent: return -1 (sentinel for miss)
     */
    public int get(int key) {
        Node node = map.get(key);
        if (node == null) {
            return -1; // MISS
        }
        list.remove(node);   // re-order to MRU
        list.addFirst(node);
        return node.value;
    }

    /**
     * Insert/Update:
     * - If key exists: update and move to MRU
     * - If new:
     *   - Evict LRU if at capacity
     *   - Insert at MRU and record in map
     */
    public void put(int key, int value) {
        Node existing = map.get(key);
        if (existing != null) {
            existing.value = value;
            list.remove(existing);
            list.addFirst(existing);
            return;
        }

        if (map.size() >= capacity) {
            Node lru = list.removeLast();
            if (lru != null) {
                map.remove(lru.key);
            }
        }

        Node node = new Node(key, value);
        list.addFirst(node);
        map.put(key, node);
    }

    // --- Optional helpers (handy for validation/testing) ---
    public int size() { return map.size(); }
    public Integer peekMostRecentKey() {
        Node h = list.getHead(); return h == null ? null : h.key;
    }
    public Integer peekLeastRecentKey() {
        Node t = list.getTail(); return t == null ? null : t.key;
    }
    public int getCapacity() { return capacity; }
}
